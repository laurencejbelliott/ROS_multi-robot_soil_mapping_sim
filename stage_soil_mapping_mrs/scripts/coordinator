#!/usr/bin/env python3
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
import random
import sys
import os
import copy
import operator
import shutil
import cv2
from math import sqrt
from time import sleep

from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String, Float64, Int64, Bool
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, PoseWithCovarianceStamped
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

# TODO:
# - Implement remaining features from Mesa simulation:
#  * Bespoke dynamic sampling (as in Mesa simulation)
# - Extend run_trials script to automate launching multiple trials
# - Environment cropping
# - Visualise sampling points in RViz
# - Integrate one or two more sophisticated task allocation algorithm
# - Dynamic sampling improvements (co-kriging, quadtree environment partitioning, etc.)

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()

increased_sim_speed = 100 # 100x faster than real time
env_width = 324 # metres
env_height = 220 # metres
robot_init_pose_algorithm = 'random' # 'realistic', 'random edge', 'random edge and robot'. Using 'random' to replicate Mesa trials. Future trials will use 'random edge and robot'

# Define parameters (Explanations are in kriging.py)
# Use Gaussian variogram model
variogram = 'gaussian'

# Set kriging grid dimensions to those the environment
x_grid = np.arange(0, ground_truth.shape[1], 1)
y_grid = np.arange(0, ground_truth.shape[0], 1)

# Define location and data of sampled points
x_arr = []
y_arr = []
o_arr = []
id_arr = []


class Coordinator:
    def __init__(self, trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor, figures_path):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        
        self.trial_num = trial_num

        # Set random seed for reproducibility
        random.seed(trial_num)

        self.num_robots = num_robots
        self.ta_algo = ta_algo
        self.sampling_algo = sampling_algo
        self.env_crop_factor = env_crop_factor
        self.figures_path = figures_path

        # Save visualisation of ground truth
        plt.imshow(ground_truth)
        plt.colorbar


        self.robot_speed = 2.0 # m/s

        # Delete existing figures directory if it exists
        if os.path.exists(self.figures_path):
            shutil.rmtree(self.figures_path)
        # Recreate figures directory
        os.mkdir(self.figures_path)
        os.mkdir(self.figures_path+'/sampled_cell_masks/')
        os.mkdir(self.figures_path+'/kriging_variance_masks/')
        

        rospy.loginfo("Arguments: trial_num: {}, num_robots: {}, ta_algo: {}, sampling_algo: {}, env_crop_factor: {}".format(
            self.trial_num, self.num_robots, self.ta_algo, self.sampling_algo, self.env_crop_factor))

        if 'round' or 'robin' or 'rr' in str(self.ta_algo).lower():
            self.rr_rob_index = 0

        if 'grid' in str(self.sampling_algo).lower():
            self.tasks = self.grid_sampling()
        elif 'random' in str(self.sampling_algo).lower():
            self.tasks = self.random_sampling()

        self.sim_time_factor = 1  # Default to 1x sim speed, gets updated by sim_time_factor_callback
        self.sim_time_factor_sub = rospy.Subscriber("/sim_time_factor", Float64, self.sim_time_factor_callback)
        self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, latch=True)
        self.sim_initialized_pub = rospy.Publisher("/sim_initialized", Bool, latch=True)

        self.allocated_course_cells = []
        self.ds_grid_mean_kriging_variance = {}
        self.sampled_cells_colorbar_plotted = False
        self.kriging_variance_colorbar_plotted = False

        # Define metrics
        self.RMSE = -1
        self.RMSEpub = rospy.Publisher(namespace + node_name + "/" + "RMSE", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.avgVar = -1
        self.avgVarpub = rospy.Publisher(namespace + node_name + "/" + "avgVar", Float64, queue_size=0, tcp_nodelay=True, latch=True)

        # Initialise kriging maps
        self.interpolated_map = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.kriging_variance = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        
        if "dynamic" in str(self.sampling_algo).lower():
            self.sampled_mask = np.ones((ground_truth.shape[0], ground_truth.shape[1]))

        self.interpolated_map_pub = rospy.Publisher(namespace + node_name + "/" + "interpolated_map", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)
        self.kriging_variance_pub = rospy.Publisher(namespace + node_name + "/" + "kriging_variance", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        # Publish placeholder maps before any data is received
        interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
        kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))

        ground_truth_ros = self.numpy_array_to_occupancy_grid(ground_truth.astype(np.int8))
        ground_truth_ros_pub = rospy.Publisher(namespace + node_name + "/" + "ground_truth", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        self.interpolated_map_pub.publish(interpolated_map_ros)
        self.kriging_variance_pub.publish(kriging_variance_ros)
        ground_truth_ros_pub.publish(ground_truth_ros)

        self.numSamples = 0
        self.numSamplespub = rospy.Publisher(namespace + node_name + "/" + "numSamples", Int64, queue_size=0, tcp_nodelay=True, latch=True)

        self.tasks = []


        # If task allocation algorithm is 'dynamic', partition the environment into a grid,
        # this is used to address oversampling in the dynamic sampling algorithm
        if 'dynamic' in str(self.sampling_algo).lower():
            ds_grid_resolution = 10 # metres
            ds_grid_x = np.arange(0, env_width, ds_grid_resolution)
            ds_grid_y = np.arange(0, env_height, ds_grid_resolution)
            self.ds_grid_x = ds_grid_x
            self.ds_grid_y = ds_grid_y
            cell_id_map = []
            self.course_cell_mean_variances = []
            for x in range(len(ds_grid_x)):
                for y in range(len(ds_grid_y)):
                    cell_id_map.append([x, y])

            # Assign each cell of the kriging grid to a cell of the dynamic sampling grid
            self.ds_grid = np.ones((env_width, env_height)) * -1
            rospy.loginfo("Length of ds_grid_x: {}".format(len(ds_grid_x)))
            rospy.loginfo("Length of ds_grid_y: {}".format(len(ds_grid_y)))
            for ds_grid_x_ix in range(0, len(ds_grid_x)):
                for ds_grid_y_ix in range(0, len(ds_grid_y)):
                    if ds_grid_x_ix == 0:
                        x_min = 0
                    else:
                        x_min = ds_grid_x_ix * ds_grid_resolution
                    if ds_grid_y_ix == 0:
                        y_min = 0
                    else:
                        y_min = ds_grid_y_ix * ds_grid_resolution
                    x_max = (ds_grid_x_ix + 1) * ds_grid_resolution
                    y_max = (ds_grid_y_ix + 1) * ds_grid_resolution

                    for x in range(x_min, x_max):
                        for y in range(y_min, y_max):
                            if x > (env_width - 1) or y > (env_height - 1):
                                continue
                            else:
                                cell_id = cell_id_map.index([ds_grid_x_ix, ds_grid_y_ix])
                                self.ds_grid[x][y] = cell_id
            
            # Plot the dynamic sampling grid
            plt.figure()

            # Create rotated grid for imshow
            self.ds_grid_rotated = np.rot90(self.ds_grid)

            plt.imshow(self.ds_grid_rotated, origin='lower', cmap='jet', interpolation='none')
            plt.colorbar()

            plt.title("Dynamic Sampling Grid")
            plt.savefig(self.figures_path+"/ds_grid.png")
            plt.close()
            rospy.loginfo("Dynamic sampling grid saved to {}".format(package_path+"/figures/ds_grid.png"))
                            
        
        # Set of robots
        self.robots = ["robot_" + str(r) for r in range(self.num_robots)]
        self.robot_pose_pubs = {}
        self.robot_intial_poses = {}
        for robot in self.robots:
            self.robot_pose_pubs[robot] = rospy.Publisher("/" + robot + "/cmd_pose", Pose, queue_size=1)

        rospy.loginfo("Robots: " + str(self.robots))

    
    def sim_time_factor_callback(self, msg):
        self.sim_time_factor = msg.data
    

    def grid_sampling(self):
        # Create grid of points to sample
        # 20 points spread evenly across the x axis, with a 5% margin on each of the edges
        sample_grid_x = np.linspace(min(x_grid) + max(x_grid) * 0.05, max(x_grid) - max(x_grid) * 0.05, 10)
        # 20 points spread evenly across the y axis, with a 5% margin on each of the edges
        sample_grid_y = np.linspace(min(y_grid) + max(y_grid) * 0.05, max(y_grid) - max(y_grid) * 0.05, 10)
        
        points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                           len(sample_grid_x))]))
        plt.imshow(ground_truth, origin="lower")
        plt.colorbar()
        # Plot X and Y of points.geoms tuples
        plt.plot([p.x for p in points.geoms], [p.y for p in points.geoms], 'ro')
        plt.title("Ground-truth with Sampling Grid")
        plt.savefig(self.figures_path+'/ground_truth_and_sampling.png')
        rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path + "/figures/ground_truth_and_sampling.png")
        
        # Convert points.geoms into list of tuples and return
        return [(p.x, p.y) for p in points.geoms]
    
    def random_sampling(self):
        # Create random points to sample
        points = [(np.random.uniform(min(x_grid), max(x_grid)), np.random.uniform(min(y_grid),
                    max(y_grid))) for _ in range(self.num_robots)]
        plt.imshow(ground_truth, origin="lower")
        plt.colorbar()
        # Plot X and Y of tuples
        plt.plot([p[0] for p in points], [p[1] for p in points], 'ro')
        plt.title("Ground truth with initial random sampling")
        plt.savefig(self.figures_path+'/ground_truth_and_random_sampling.png')
        rospy.loginfo("Saved ground truth and random sampling plot to " + package_path + "/figures/ground_truth_and_random_sampling.png")

        return points
    
    def dynamic_sampling(self):
        # Get the 2x highest mean kriging variance course-grain cells, where x is the number of robots
        points = []

        # Get the mean kriging variance for each cell in the dynamic sampling grid
        num_sampling_grid_cells = len(self.ds_grid_x) * len(self.ds_grid_y)
        self.ds_grid_mean_kriging_variance = {}
        for cell_id in range(num_sampling_grid_cells):
            # Get the indices of the cells in the dynamic sampling grid that belong to the current cell_id
            cell_indices = np.argwhere(self.ds_grid == cell_id)
            # Get the mean kriging variance of the current cell_id
            self.ds_grid_mean_kriging_variance[cell_id] = np.mean(self.kriging_variance[cell_indices[:, 0:-1], cell_indices[:, 1:-1]])

        # Exclude the cells that have already been allocated
        for cell_id in self.allocated_course_cells:
            try:
                self.ds_grid_mean_kriging_variance.pop(cell_id)
            except KeyError:
                pass

        # Get the 2x highest mean kriging variance cells
        sorted_ds_grid_mean_kriging_variance = sorted(copy.deepcopy(self.ds_grid_mean_kriging_variance).items(), key=operator.itemgetter(1), reverse=True)

        goal_cells = []
        # Exclude these cells from future rounds of dynamic sampling
        for cell_id, _ in sorted_ds_grid_mean_kriging_variance[:self.num_robots*2]:
            self.allocated_course_cells.append(cell_id)
            goal_cells.append(cell_id)

        # Get the highest kriging variance cell (point) in each of the more course-grain cells which have the highest mean kriging variance
        for cell_id in goal_cells:
            # Get the indices of the cells in the dynamic sampling grid that belong to the current cell_id
            cell_indices = np.argwhere(self.ds_grid == cell_id)
            # rospy.loginfo("cell_indices: " + str(cell_indices))
            kriging_v_rotated = np.rot90(self.kriging_variance)
            kriging_variance_cropped_to_cell = kriging_v_rotated[cell_indices[:, 0], cell_indices[:, 1]]
            # rospy.loginfo("kriging_variance_cropped_to_cell: " + str(kriging_variance_cropped_to_cell))
            max_v_cell = cell_indices[np.unravel_index(kriging_variance_cropped_to_cell.argmax(), kriging_variance_cropped_to_cell.shape)[0]]
            points.append(max_v_cell)

        # rospy.loginfo("New dynamic sampling goals: " + str(points))

        return points



    def calculate_path_cost(self, robot_position, task_position):
        # Calculate path cost
        # Euclidean distance between robot and task, multiplied by constant robot_speed
        return np.sqrt((robot_position[0] - task_position[0]) ** 2 + (robot_position[1] - task_position[1]) ** 2) * self.robot_speed


    def rr_ta(self):  # Round Robin Task Allocation
        rospy.loginfo("Executing Round Robin Task Allocation...")
        ta = {}
        for robot in self.robots:
            ta[robot] = []
        print("Robots are: " + str(self.robots))
        for _ in range(len(self.tasks)):
            if len(self.tasks) > 0:
                task = self.tasks.pop(0)
                # print("Robot ID for current allocation is " + str(self.rr_rob_index))
                ta["robot_" + str(self.rr_rob_index)].append(task)
                if self.rr_rob_index == len(self.robots) - 1:
                    self.rr_rob_index = 0
                else:
                    self.rr_rob_index += 1
        return ta
    

    def ssi_ta(self): # Sequential Single-Item Task Allocation
        rospy.loginfo("Executing Sequential Single-Item Task Allocation...")
        ta = {}
        for robot in self.robots:
            ta[robot] = []
        print("Robots are: " + str(self.robots))
        for _ in range(len(self.tasks)):
            if len(self.tasks) > 0:
                task = self.tasks.pop(0)
                bids = []
                for robot in self.robots:
                    # Get robot position
                    robot_pose_msg = rospy.wait_for_message("/" + robot + "/amcl_pose", PoseWithCovarianceStamped)
                    robot_position = (robot_pose_msg.pose.pose.position.x, robot_pose_msg.pose.pose.position.y)

                    # Calculate path cost for robot to navigate to task
                    bid = self.calculate_path_cost(robot_position, task)
                    bids.append(bid)
                
                rospy.loginfo("\nTask: " + str(task) + ". Bids:")
                for b in range(len(bids)):
                    rospy.loginfo("robot_"+str(b)+": " + str(bids[b]))

                # Get index of max bid
                min_bid_index = bids.index(min(bids))

                rospy.loginfo("robot_"+str(min_bid_index)+" wins with bid: " + str(bids[min_bid_index]))

                ta["robot_" + str(min_bid_index)].append(task)

        # Sort each robot's task queue to minimize the distance they must travel to reach all their tasks
        for robot in self.robots:
            sorted_tasks = sorted(ta[robot], key=lambda x: self.calculate_path_cost(robot_position, x))
            ta[robot] = sorted_tasks

        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        x_arr.append([data["x"]])
        y_arr.append([data["y"]])
        o_arr.append(float(data["reading"]))
        id_arr.append(data["robot_id"])

        c_arr = []
        for i in range(len(id_arr)):
            if id_arr[i] == "robot_0":
                c_arr.append('r')
            elif id_arr[i] == "robot_1":
                c_arr.append('g')
        
        # Need at least 3 points to interpolate
        if len(x_arr) > 2:
            print("Setting sim. speed to 1x while interpolating...")

            # Set sim speed to 1x
            self.sim_time_factor_pub.publish(1.0)

            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(x_grid, y_grid, x_arr, y_arr, o_arr, variogram=variogram)

            self.interpolated_map, self.kriging_variance = m, v

            # Publish interpolation maps
            interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
            kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
            self.interpolated_map_pub.publish(interpolated_map_ros)
            self.kriging_variance_pub.publish(kriging_variance_ros)

            # Calculate interpolation metrics
            self.RMSE = np.sqrt(np.mean((m - ground_truth) ** 2))
            self.avgVar = np.mean(v)

            rospy.loginfo("Interpolation complete")
            
            print("Setting sim. speed back to " + str(increased_sim_speed) + "x...")
            self.sim_time_factor_pub.publish(increased_sim_speed)
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(x_arr)))

    def numpy_array_to_occupancy_grid(self, numpy_array): # Convert numpy array to OccupancyGrid message
        # Upscale numpy array by 20x for better visualisation
        numpy_array = cv2.resize(numpy_array, (numpy_array.shape[1]*20, numpy_array.shape[0]*20), interpolation=cv2.INTER_NEAREST)

        # Create OccupancyGrid message
        occupancy_grid = OccupancyGrid()
        occupancy_grid.header.frame_id = "map"
        occupancy_grid.info.resolution = 0.05
        occupancy_grid.info.width = numpy_array.shape[1]
        occupancy_grid.info.height = numpy_array.shape[0]
        occupancy_grid.info.origin.position.x = 0
        occupancy_grid.info.origin.position.y = 0
        occupancy_grid.info.origin.position.z = 0
        occupancy_grid.info.origin.orientation.x = 0
        occupancy_grid.info.origin.orientation.y = 0
        occupancy_grid.info.origin.orientation.z = 0
        occupancy_grid.info.origin.orientation.w = 1
        occupancy_grid.data = numpy_array.flatten().tolist()
        return occupancy_grid
    
    def random_edge_pose(self):
        # Choose random pose within 5m of the edge of the environment
        pose = Pose()
        
        # Choose random edge
        edge = random.randint(0, 3)
        
        if edge == 0: # North
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(env_height-6, env_height-1)
        elif edge == 1: # East
            pose.position.x = random.uniform(env_width-6, env_width-1)
            pose.position.y = random.uniform(1, env_height-1)
        elif edge == 2: # South
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(1, 6)
        elif edge == 3: # West
            pose.position.x = random.uniform(1, 6)
            pose.position.y = random.uniform(1, env_height-1)
        
        # # Convert position from stage coordinates to ROS coordinates
        pose.position.x = pose.position.x - env_width/2
        pose.position.y = pose.position.y - env_height/2

        pose.orientation.w = 1

        return pose
    
    def new_sample_callback(self, data):
        if self.sampling_algo == "dynamic":
            # Update sampled cells mask
            data_json = copy.deepcopy(data)

            data_json = str(data_json.data).replace("'", '"')
            data_json = json.loads(data_json)

            cluster_id = self.ds_grid[int(data_json["x"])][int(data_json["y"])]
            self.sampled_mask[self.ds_grid_rotated == cluster_id] = -1
            
            # Save visualisation of sampled cells mask
            if self.numSamples % 1 == 0: # Save every 1 samples
                plt.imshow(self.sampled_mask)
                plt.title("Sampled Cells Mask")
                plt.colorbar()
                plt.annotate("Min: " + str(np.min(self.sampled_mask)), (0, 0), (0, -20), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.annotate("Max: " + str(np.max(self.sampled_mask)), (0, 0), (0, -40), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.savefig(self.figures_path+"/sampled_cell_masks/sampled_mask_" + str(self.numSamples) + ".png")
                plt.close()

                # Save visualisation of kriging variance with sampled cells mask applied
                variance_masked = self.kriging_variance * self.sampled_mask
                plt.imshow(variance_masked)
                plt.title("Kriging Variance x Sampled Cells Convolution")
                plt.colorbar()
                plt.annotate("Min: " + str(np.min(variance_masked)), (0, 0), (0, -20), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.annotate("Max: " + str(np.max(variance_masked)), (0, 0), (0, -40), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.annotate("Mean: " + str(np.mean(variance_masked)), (0, 0), (0, -60), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.annotate("Median: " + str(np.median(variance_masked)), (0, 0), (0, -80), xycoords='axes fraction', textcoords='offset points', va='top')
                plt.savefig(self.figures_path+"/kriging_variance_masks/kriging_variance_mask_" + str(self.numSamples) + ".png")
                plt.close()

        self.metricPubNumSamples()
        self.interpolate_and_visualise(data.data)
        self.metricPubRMSE()
        self.metricPubAvgVariance()

        # Generate new sampling goals
        if "grid" not in self.sampling_algo:
            if "random" in self.sampling_algo:
                self.tasks += self.random_sampling()
            elif "dynamic" in self.sampling_algo and self.numSamples >= 2:
                if np.mean(self.kriging_variance) >= -1:
                    rospy.loginfo("Generating sampling goals with dynamic sampling...")
                    self.tasks += self.dynamic_sampling()
            
            if "round" in str(self.ta_algo).lower() or "robin" in str(self.ta_algo).lower() or "rr" in str(self.ta_algo).lower():
                rospy.loginfo("Round robin running with ta_algo selected: " + str(self.ta_algo))
                self.publish_ta(self.rr_ta())
            if "SSI" in str(self.ta_algo).upper():
                rospy.loginfo("SSI running with ta_algo selected: " + str(self.ta_algo))
                self.publish_ta(self.ssi_ta())
        self.numSamples += 1

    def metricPubRMSE(self): # Publish Root Mean Squared Error
        self.RMSEpub.publish(self.RMSE)
        rospy.loginfo("Root Mean Squared Error: %.2f" % self.RMSE)

    def metricPubAvgVariance(self): # Publish Average Kriging Variance
        self.avgVarpub.publish(self.avgVar)

    def metricPubNumSamples(self): # Publish Number of Samples
        self.numSamplespub.publish(self.numSamples)


if __name__ == '__main__':
    myargv = rospy.myargv(argv=sys.argv)

    if len(myargv) > 0:
        trial_num = int(myargv[1])
        num_robots = int(myargv[2])
        ta_algo = myargv[3]
        sampling_algo = myargv[4]
        env_crop_factor = int(myargv[5])
        figures_path = myargv[6]

        coordinator = Coordinator(trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor, figures_path)
    else:
        rospy.logerr("No args provided")
        sys.exit(1)



    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))
    if len(pen_reading_topics) == 0:
        rospy.logerr("No topics found for simulated penetrometer readings, is the simulation running?")
        sys.exit(1)

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)

    rospy.loginfo("Waiting for simulation to start before publishing initial poses")
    sleep(5)

    # Set initial robot poses according to the chosen alogrithm
    if robot_init_pose_algorithm == "realistic": # Set robot poses within 5m of the field's gate (Northwestern corner)
        rospy.loginfo("Setting robot poses using 'realistic' algorithm")
        for robot in coordinator.robots:
            pose = Pose()
            pose.position.x = random.uniform(1, 5)
            pose.position.y = random.uniform(env_height-6, env_height-1)
            pose.orientation.w = 1

            coordinator.robot_intial_poses[robot] = (pose.position.x, pose.position.y)

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge":
        rospy.loginfo("Setting robot poses using 'random edge' algorithm")
        for robot in coordinator.robots:
            # Random edge
            # 0 = North, 1 = East, 2 = South, 3 = West
            edge = random.randint(0, 3)

            # Choose random pose within 5m of the edge
            pose = coordinator.random_edge_pose()
            coordinator.robot_intial_poses[robot] = (pose.position.x, pose.position.y)
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge and robot":
        rospy.loginfo("Setting robot poses using 'random edge and robot' algorithm")
        first_robot_pose = Pose()
        first_robot = True

        for robot in coordinator.robots:
            if first_robot:
                pose = coordinator.random_edge_pose()
                coordinator.robot_intial_poses[robot] = (pose.position.x, pose.position.y)
                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
                first_robot_pose = pose
                first_robot = False
            else:
                # Choose random pose within 5m of the edge and the first robot
                pose = coordinator.random_edge_pose()
                distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)
                while distance > 5:
                    pose = coordinator.random_edge_pose()
                    distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)

                coordinator.robot_intial_poses[robot] = (pose.position.x, pose.position.y)
                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random":
        rospy.loginfo("Setting robot poses using 'random' algorithm")
        for robot in coordinator.robots:
            x = random.uniform(1, env_width-1)
            y = random.uniform(1, env_height-1)
            coordinator.robot_intial_poses[robot] = (x, y)
            rospy.loginfo("Robot " + robot + " initial pose: " + str((x, y)))

            pose = Pose()
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(1, env_height-1)
            pose.orientation.w = 1

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            coordinator.robot_pose_pubs[robot].publish(pose)


    # Wait for robot initial poses to be registered in the simulation
    rospy.loginfo("Waiting for robot initial poses to be registered in the simulation")
    sleep(5)

    # Publish to '/sim_initialized' topic
    rospy.loginfo("Publishing to '/sim_initialized' topic")
    coordinator.sim_initialized_pub.publish(True)

    # If sampling algorithm is 'dynamic', have each robot sample at its initial position
    # get initial kriging variance needed to select sampling points
    if 'dynamic' in str(coordinator.sampling_algo).lower():
        ta = {}
        for robot in coordinator.robots:
            robot_pose = rospy.wait_for_message("/"+robot+"/amcl_pose", PoseWithCovarianceStamped)
            robot_position = (robot_pose.pose.pose.position.x, robot_pose.pose.pose.position.y)

            ta[robot] = [robot_position]
        coordinator.publish_ta(ta)

        # Wait for robots to finish sampling initial positions
        rospy.sleep(20)

        # # Run initial dynamic sampling
        # coordinator.tasks = coordinator.dynamic_sampling()

    # If sampling algorithm is 'random', create random tasks
    if 'random' in str(coordinator.sampling_algo).lower():
        coordinator.tasks = coordinator.random_sampling()
    
    # Initial task allocation
    if "round" in str(coordinator.ta_algo).lower() or "robin" in str(coordinator.ta_algo).lower() or "rr" in str(coordinator.ta_algo).lower():
        # Get Round Robin task allocations
        task_allocations = coordinator.rr_ta()
        rospy.loginfo("Round robin task allocations: " + str(task_allocations))
        plt.close()
        plt.imshow(ground_truth, origin="lower")
        for robot in coordinator.robots:
            if robot == "robot_0":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
            elif robot == "robot_1":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
        plt.savefig(package_path+'/figures/round_robin_task_allocation.png')
    elif "SSI" in str(coordinator.ta_algo).upper():
        task_allocations = coordinator.ssi_ta()
        rospy.loginfo("SSI task allocations: " + str(task_allocations))
    
    coordinator.publish_ta(task_allocations)

    # Speed up simulation and keep coordinator node running until ROS is shutdown
    coordinator.sim_time_factor_pub.publish(increased_sim_speed)
    rospy.spin()
