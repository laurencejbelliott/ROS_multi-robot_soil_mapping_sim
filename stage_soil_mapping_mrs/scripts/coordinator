#!/usr/bin/env python3
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
import random
import sys
import cv2
from math import sqrt
from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String, Float64, Int64, Bool
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

# Set random seed for reproducibility
random.seed(0)

# TODO:
# - Update RMSE algo. to fix bug with cropped environment
# - Visualise sampling points in RViz
# - Port dynamic sampling from Mesa simulation
# - Integrate one or two more sophisticated task allocation algorithm
# - Dynamic sampling improvements (co-kriging, quadtree environment partitioning, etc.)

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()

increased_sim_speed = 500 # 500x faster than real time
env_width = 324 # metres
env_height = 220 # metres
robot_init_pose_algorithm = 'random edge and robot' # 'realistic', 'random edge', 'random edge and robot'


class Coordinator:
    def __init__(self, trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        
        self.trial_num = trial_num
        random.seed(self.trial_num)
        self.num_robots = num_robots
        self.ta_algo = ta_algo
        self.sampling_algo = sampling_algo
        self.env_crop_factor = env_crop_factor

        self.env_full_width = env_width
        self.env_full_height = env_height

        self.env_cropped_width = env_width / self.env_crop_factor
        self.env_cropped_height = env_height / self.env_crop_factor

        if self.env_crop_factor > 1:
            self.env_origin_x = (self.env_cropped_width / 2) * -1
            self.env_origin_y = (self.env_cropped_width / 2) * -1
        else:
            self.env_origin_x = 0
            self.env_origin_y = 0

        rospy.loginfo("Arguments: trial_num: {}, num_robots: {}, ta_algo: {}, sampling_algo: {}, env_crop_factor: {}".format(
            self.trial_num, self.num_robots, self.ta_algo, self.sampling_algo, self.env_crop_factor))
        
        self.ground_truth = ground_truth

        # Crop ground truth to match environment size
        if self.env_crop_factor > 1:
            self.ground_truth = self.ground_truth[0:int(self.env_cropped_height), 0:int(self.env_cropped_width)]
        
        # Define parameters (Explanations are in kriging.py)
        # Use Gaussian variogram model
        self.variogram = 'gaussian'

        # Set kriging grid dimensions to those the environment
        # self.x_grid = np.arange(0, ground_truth.shape[1], 1)
        # self.y_grid = np.arange(0, ground_truth.shape[0], 1)
        self.x_grid = np.arange(0, self.env_cropped_width, 1)
        self.y_grid = np.arange(0, self.env_cropped_height, 1)

        # Define location and data of sampled points
        self.x_arr = []
        self.y_arr = []
        self.o_arr = []
        self.id_arr = []

        # Define task allocation algorithm
        if str(self.ta_algo).lower() == 'round robin':
            self.rr_rob_index = 0

        if 'grid' in str(self.sampling_algo).lower():
            points = self.grid_sampling()
            self.tasks = [(point.x, point.y) for point in points.geoms]
        
        self.start_time = rospy.Time.now().to_sec()
        self.sampling_time_budget = 60 * 120 # 2 hours (60 seconds * 120 for 120 minutes in seconds)

        self.sim_time_factor = 1  # Default to 1x sim speed, gets updated by sim_time_factor_callback
        self.sim_time_factor_sub = rospy.Subscriber("/sim_time_factor", Float64, self.sim_time_factor_callback)
        # self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, latch=True)

        # Define metrics
        self.RMSE = -1
        self.RMSEpub = rospy.Publisher(namespace + node_name + "/" + "RMSE", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.avgVar = -1
        self.avgVarpub = rospy.Publisher(namespace + node_name + "/" + "avgVar", Float64, queue_size=0, tcp_nodelay=True, latch=True)

        self.sampling_time_budget_elapsed_pub = rospy.Publisher("/sampling_time_budget_elapsed", Bool, queue_size=1)

        # Initialise kriging maps
        self.interpolated_map = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.kriging_variance = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.interpolated_map_pub = rospy.Publisher(namespace + node_name + "/" + "interpolated_map", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)
        self.kriging_variance_pub = rospy.Publisher(namespace + node_name + "/" + "kriging_variance", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        # Publish placeholder maps before any data is received
        interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
        kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
        self.interpolated_map_pub.publish(interpolated_map_ros)
        self.kriging_variance_pub.publish(kriging_variance_ros)

        self.numSamples = 0
        self.numSamplespub = rospy.Publisher(namespace + node_name + "/" + "numSamples", Int64, queue_size=0, tcp_nodelay=True, latch=True)

        # Set of robots
        self.robots = ["robot_" + str(r) for r in range(self.num_robots)]
        self.robot_pose_pubs = {}
        for robot in self.robots:
            self.robot_pose_pubs[robot] = rospy.Publisher("/" + robot + "/cmd_pose", Pose, queue_size=1)

        rospy.loginfo("Robots: " + str(self.robots))

    
    def sim_time_factor_callback(self, msg):
        self.sim_time_factor = msg.data

    def grid_sampling(self):
        # Grid sampling
        # Create grid of points to sample
        # 20 points spread evenly across the x axis, with a 5% margin on each of the edges
        sample_grid_x = np.linspace(min(self.x_grid) + max(self.x_grid) * 0.05, max(self.x_grid) - max(self.x_grid) * 0.05, 10)
        # 20 points spread evenly across the y axis, with a 5% margin on each of the edges
        sample_grid_y = np.linspace(min(self.y_grid) + max(self.y_grid) * 0.05, max(self.y_grid) - max(self.y_grid) * 0.05, 10)

        points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                                len(sample_grid_x))]))
        plt.imshow(ground_truth, origin="lower")
        plt.colorbar()
        plt.plot([point.x for point in points.geoms], [point.y for point in points.geoms], 'bo')
        plt.title("Ground truth with sampling grid")
        plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png')
        rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path +
                    "/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png")
        
        return points
    

    def rr_ta(self):  # Round Robin Task Allocation
        ta = {}
        for robot in self.robots:
            ta[robot] = []
        print("Robots are: " + str(self.robots))
        for task in self.tasks:
            print("Robot ID for current allocation is " + str(self.rr_rob_index))
            ta["robot_" + str(self.rr_rob_index)].append(task)
            if self.rr_rob_index == len(self.robots) - 1:
                self.rr_rob_index = 0
            else:
                self.rr_rob_index += 1
        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        self.x_arr.append([data["x"]])
        self.y_arr.append([data["y"]])
        self.o_arr.append(float(data["reading"]))
        self.id_arr.append(data["robot_id"])

        # rospy.loginfo("x_arr len: " + str(len(x_arr)))
        # rospy.loginfo("y_arr len: " + str(len(y_arr)))
        # rospy.loginfo("o_arr len: " + str(len(o_arr)))
        # rospy.loginfo("id_arr len: " + str(len(id_arr)))

        c_arr = []
        for i in range(len(self.id_arr)):
            if self.id_arr[i] == "robot_0":
                c_arr.append('r')
            elif self.id_arr[i] == "robot_1":
                c_arr.append('g')

        # rospy.loginfo("c_arr len: " + str(len(c_arr)))

        # Need at least 3 points to interpolate
        if len(self.x_arr) > 2:
            print("Setting sim. speed to 1x while interpolating...")

            # Set sim speed to 1x
            self.sim_time_factor_pub.publish(1.0)

            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(self.x_grid, self.y_grid, self.x_arr, self.y_arr, self.o_arr, variogram=self.variogram)

            self.interpolated_map, self.kriging_variance = m, v
            # Publish interpolation maps
            interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
            kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
            self.interpolated_map_pub.publish(interpolated_map_ros)
            self.kriging_variance_pub.publish(kriging_variance_ros)

            # Calculate interpolation metrics
            self.RMSE = np.sqrt(np.mean((m - self.ground_truth) ** 2))
            self.avgVar = np.mean(v)

            rospy.loginfo("Interpolation complete")
            print("Setting sim. speed back to " + str(increased_sim_speed) + "x...")
            self.sim_time_factor_pub.publish(increased_sim_speed)
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(self.x_arr)))


    def numpy_array_to_occupancy_grid(self, numpy_array): # Convert numpy array to OccupancyGrid message
        # Upscale numpy array by 20x for better visualisation
        numpy_array = cv2.resize(numpy_array, (numpy_array.shape[1]*20, numpy_array.shape[0]*20), interpolation=cv2.INTER_NEAREST)

        # Create OccupancyGrid message
        occupancy_grid = OccupancyGrid()
        occupancy_grid.header.frame_id = "map"
        occupancy_grid.info.resolution = 0.05
        occupancy_grid.info.width = numpy_array.shape[1]
        occupancy_grid.info.height = numpy_array.shape[0]

        if self.env_crop_factor == 1:
            occupancy_grid.info.origin.position.x = self.env_full_width / 2
            occupancy_grid.info.origin.position.y = self.env_full_height / 2
        elif self.env_crop_factor == 2:
            occupancy_grid.info.origin.position.x = self.env_full_width / 4
            occupancy_grid.info.origin.position.y = self.env_full_height / 4
        elif self.env_crop_factor == 4:
            occupancy_grid.info.origin.position.x = self.env_origin_x + self.env_full_width / 2
            occupancy_grid.info.origin.position.y = self.env_origin_y + self.env_full_height / 1.75
        occupancy_grid.info.origin.position.z = 0
        occupancy_grid.info.origin.orientation.x = 0
        occupancy_grid.info.origin.orientation.y = 0
        occupancy_grid.info.origin.orientation.z = 0
        occupancy_grid.info.origin.orientation.w = 1
        occupancy_grid.data = numpy_array.flatten().tolist()
        return occupancy_grid
    
    def random_edge_pose(self):
        # Choose random pose within 5m of the edge of the environment
        pose = Pose()
        
        # Choose random edge
        edge = random.randint(0, 3)

        # Using cropped environment dimensions
        if edge == 0: # North
            pose.position.x = random.uniform(1, self.env_cropped_width-1)
            pose.position.y = random.uniform(self.env_cropped_height-6, self.env_cropped_height-1)
        elif edge == 1: # East
            pose.position.x = random.uniform(self.env_cropped_width-6, self.env_cropped_width-1)
            pose.position.y = random.uniform(1, self.env_cropped_height-1)
        elif edge == 2: # South
            pose.position.x = random.uniform(1, self.env_cropped_width-1)
            pose.position.y = random.uniform(1, 6)
        elif edge == 3: # West
            pose.position.x = random.uniform(1, 6)
            pose.position.y = random.uniform(1, self.env_cropped_height-1)
        
        # Convert position from stage coordinates to ROS coordinates
        pose.position.x = pose.position.x - coordinator.env_cropped_width/2
        pose.position.y = pose.position.y - coordinator.env_cropped_height/2

        pose.orientation.w = 1

        return pose
    
    def new_sample_callback(self, data):
        self.numSamples += 1
        self.metricPubNumSamples()
        self.interpolate_and_visualise(data.data)
        self.metricPubRMSE()
        self.metricPubAvgVariance()

    def metricPubRMSE(self): # Publish Root Mean Squared Error
        self.RMSEpub.publish(self.RMSE)
        rospy.loginfo("Root Mean Squared Error: %.2f" % self.RMSE)

    def metricPubAvgVariance(self): # Publish Average Kriging Variance
        self.avgVarpub.publish(self.avgVar)

    def metricPubNumSamples(self): # Publish Number of Samples
        self.numSamplespub.publish(self.numSamples)


if __name__ == '__main__':
    myargv = rospy.myargv(argv=sys.argv)

    if len(myargv) > 0:
        trial_num = int(myargv[1])
        num_robots = int(myargv[2])
        ta_algo = myargv[3]
        sampling_algo = myargv[4]
        env_crop_factor = int(myargv[5])

        coordinator = Coordinator(trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor)
    else:
        rospy.logerr("No args provided")
        sys.exit(1)



    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))
    if len(pen_reading_topics) == 0:
        rospy.logerr("No topics found for simulated penetrometer readings, is the simulation running?")
        sys.exit(1)

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)
        
    if "grid" in str(coordinator.sampling_algo).lower():
        points = coordinator.grid_sampling()
    
    if "robin" in str(coordinator.ta_algo).lower():
        # Get Round Robin task allocations
        task_allocations = coordinator.rr_ta()
        rospy.loginfo("Round robin task allocations: " + str(task_allocations))
        plt.close()
        plt.imshow(ground_truth, origin="lower")
        for robot in coordinator.robots:
            if robot == "robot_0":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
            elif robot == "robot_1":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
        plt.savefig(package_path+'/include/stage_soil_mapping_mrs/round_robin_task_allocation.png')

    # Set initial robot poses according to the chosen alogrithm
    if robot_init_pose_algorithm == "realistic": # Set robot poses within 5m of the field's gate (Northwestern corner)
        rospy.loginfo("Setting robot poses using 'realistic' algorithm")
        for robot in coordinator.robots:
            pose = Pose()
            pose.position.x = random.uniform(1, 5)
            pose.position.y = random.uniform(env_height-6, env_height-1)

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            pose.orientation.w = 1
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge":
        rospy.loginfo("Setting robot poses using 'random edge' algorithm")
        for robot in coordinator.robots:
            # Random edge
            # 0 = North, 1 = East, 2 = South, 3 = West
            edge = random.randint(0, 3)

            # Choose random pose within 5m of the edge
            pose = coordinator.random_edge_pose()
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge and robot":
        rospy.loginfo("Setting robot poses using 'random edge and robot' algorithm")
        first_robot_pose = Pose()
        first_robot = True

        for robot in coordinator.robots:
            if first_robot:
                pose = coordinator.random_edge_pose()
                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
                first_robot_pose = pose
                first_robot = False
            else:
                # Choose random pose within 5m of the edge and the first robot
                pose = coordinator.random_edge_pose()
                distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)
                # Keep choosing random poses until the distance is greater than 5m and within the bounds of the environment
                # Print environment bounds for debugging
                rospy.loginfo("Environment bounds: x = [" + str(coordinator.env_origin_x) + ", " + str(coordinator.env_cropped_width) + "], y = [" + str(coordinator.env_origin_y) + ", " + str(coordinator.env_cropped_height) + "]")

                while distance > 5 or pose.position.x < coordinator.env_origin_x or pose.position.x > coordinator.env_cropped_width or pose.position.y < coordinator.env_origin_y or \
                    pose.position.y > coordinator.env_cropped_height:
                    pose = coordinator.random_edge_pose()
                    distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)

                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
                

    coordinator.publish_ta(task_allocations)

    # Speed up simulation
    coordinator.sim_time_factor_pub.publish(increased_sim_speed)

    # Check if sampling time budget has elapsed
    while not rospy.is_shutdown():
        now = rospy.Time.now().to_sec()
        if now - coordinator.start_time > coordinator.sampling_time_budget:
            rospy.loginfo("Sampling time budget elapsed (%s seconds)" % coordinator.sampling_time_budget)
            coordinator.sampling_time_budget_elapsed_pub.publish(True)
            rospy.signal_shutdown("Sampling time budget elapsed")
            break
        rospy.sleep(0.1)
