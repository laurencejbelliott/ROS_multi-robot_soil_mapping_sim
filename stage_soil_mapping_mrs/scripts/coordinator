#!/usr/bin/env python
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()


# Define parameters (Explanations are in kriging.py)

# Use Gaussian variogram model
variogram = 'gaussian'

# Set kriging grid dimensions to those the environment
x_grid = np.arange(0, ground_truth.shape[1], 1)
y_grid = np.arange(0, ground_truth.shape[0], 1)

# Define location and data of sampled points
x_arr = []
y_arr = []
o_arr = []
id_arr = []

# Create grid of points to sample
# 20 points spread evenly across the x axis, with a 5% margin on each of the edges
sample_grid_x = np.linspace(min(x_grid) + max(x_grid) * 0.05, max(x_grid) - max(x_grid) * 0.05, 10)
# 20 points spread evenly across the y axis, with a 5% margin on each of the edges
sample_grid_y = np.linspace(min(y_grid) + max(y_grid) * 0.05, max(y_grid) - max(y_grid) * 0.05, 10)

points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                        len(sample_grid_x))]))
# print("Points: {}".format(points))
plt.imshow(ground_truth, origin="lower")
plt.colorbar()
plt.plot([point.x for point in points], [point.y for point in points], 'bo')
plt.title("Ground truth with sampling grid")
plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png')
rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path +
              "/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png")


class Coordinator:
    def __init__(self):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        self.rr_rob_index = 0
        self.tasks = [(point.x, point.y) for point in points]

        # Set of robots
        self.robots = ["robot_0", "robot_1"]
        rospy.loginfo("Robots: " + str(self.robots))

    def rr_ta(self):  # Round Robin Task Allocation
        ta = {"robot_0": [], "robot_1": []}
        print("Robots are: " + str(self.robots))
        for task in self.tasks:
            print("Robot ID for current allocation is " + str(self.rr_rob_index))
            ta["robot_" + str(self.rr_rob_index)].append(task)
            if self.rr_rob_index == len(self.robots) - 1:
                self.rr_rob_index = 0
            else:
                self.rr_rob_index += 1
        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        x_arr.append([data["x"]])
        y_arr.append([data["y"]])
        o_arr.append(float(data["reading"]))
        id_arr.append(data["robot_id"])
        c_arr = []
        for i in range(len(id_arr)):
            if id_arr[i] == "robot_0":
                c_arr.append('r')
            elif id_arr[i] == "robot_1":
                c_arr.append('g')

        # Need at least 3 points to interpolate
        if len(x_arr) > 2:
            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(x_grid, y_grid, x_arr, y_arr, o_arr, variogram=variogram)

            plt.close()
            plt.scatter(x_arr, y_arr, c=c_arr)
            plt.imshow(m, origin="lower")
            plt.title("Interpolation of " + str(len(x_arr)) + " samples")
            plt.colorbar()
            plt.savefig(package_path+'/include/stage_soil_mapping_mrs/interpolated.png')
            rospy.loginfo("Saved interpolation plot to " + package_path+"/include/stage_soil_mapping_mrs/interpolated.png")
            plt.show(block=False)
            plt.pause(1)
            rospy.loginfo("Interpolation complete")
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(x_arr)))


    def new_sample_callback(self, data):
        # print("Received new sample: " + data.data)
        self.interpolate_and_visualise(data.data)


if __name__ == '__main__':
    coordinator = Coordinator()

    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)

    # Get Round Robin task allocations
    task_allocations = coordinator.rr_ta()
    rospy.loginfo("Round robin task allocations: " + str(task_allocations))
    plt.close()
    plt.imshow(ground_truth, origin="lower")
    for robot in coordinator.robots:
        if robot == "robot_0":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
        elif robot == "robot_1":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
    plt.savefig(package_path+'/include/stage_soil_mapping_mrs/round_robin_task_allocation.png')

    coordinator.publish_ta(task_allocations)
    rospy.spin()
