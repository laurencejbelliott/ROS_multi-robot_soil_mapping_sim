#!/usr/bin/env python3
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
import random
import sys
import cv2
from math import sqrt
from time import sleep
from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String, Float64, Int64, Bool
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, PoseWithCovarianceStamped
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

# TODO:
# - Implement remaining features from Mesa simulation:
#  * Sequential Single Item task allocation
#  * Bespoke dynamic sampling (as in Mesa simulation)
# - Extend run_trials script to automate launching multiple trials
# - Environment cropping
# - Visualise sampling points in RViz
# - Integrate one or two more sophisticated task allocation algorithm
# - Dynamic sampling improvements (co-kriging, quadtree environment partitioning, etc.)

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()

increased_sim_speed = 100 # 100x faster than real time
env_width = 324 # metres
env_height = 220 # metres
robot_init_pose_algorithm = 'random' # 'realistic', 'random edge', 'random edge and robot'. Using 'random' to replicate Mesa trials. Future trials will use 'random edge and robot'

# Define parameters (Explanations are in kriging.py)
# Use Gaussian variogram model
variogram = 'gaussian'

# Set kriging grid dimensions to those the environment
x_grid = np.arange(0, ground_truth.shape[1], 1)
y_grid = np.arange(0, ground_truth.shape[0], 1)

# Define location and data of sampled points
x_arr = []
y_arr = []
o_arr = []
id_arr = []


class Coordinator:
    def __init__(self, trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        
        self.trial_num = trial_num

        # Set random seed for reproducibility
        random.seed(trial_num)

        self.num_robots = num_robots
        self.ta_algo = ta_algo
        self.sampling_algo = sampling_algo
        self.env_crop_factor = env_crop_factor

        self.robot_speed = 2.0 # m/s

        rospy.loginfo("Arguments: trial_num: {}, num_robots: {}, ta_algo: {}, sampling_algo: {}, env_crop_factor: {}".format(
            self.trial_num, self.num_robots, self.ta_algo, self.sampling_algo, self.env_crop_factor))

        if 'round' or 'robin' or 'rr' in str(self.ta_algo).lower():
            self.rr_rob_index = 0

        if 'grid' in str(self.sampling_algo).lower():
            self.tasks = self.grid_sampling()
        elif 'random' in str(self.sampling_algo).lower():
            self.tasks = self.random_sampling()

        self.sim_time_factor = 1  # Default to 1x sim speed, gets updated by sim_time_factor_callback
        self.sim_time_factor_sub = rospy.Subscriber("/sim_time_factor", Float64, self.sim_time_factor_callback)
        self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, latch=True)
        self.sim_initialized_pub = rospy.Publisher("/sim_initialized", Bool, latch=True)

        # Define metrics
        self.RMSE = -1
        self.RMSEpub = rospy.Publisher(namespace + node_name + "/" + "RMSE", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.avgVar = -1
        self.avgVarpub = rospy.Publisher(namespace + node_name + "/" + "avgVar", Float64, queue_size=0, tcp_nodelay=True, latch=True)

        # Initialise kriging maps
        self.interpolated_map = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.kriging_variance = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.interpolated_map_pub = rospy.Publisher(namespace + node_name + "/" + "interpolated_map", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)
        self.kriging_variance_pub = rospy.Publisher(namespace + node_name + "/" + "kriging_variance", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        # Publish placeholder maps before any data is received
        interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
        kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
        self.interpolated_map_pub.publish(interpolated_map_ros)
        self.kriging_variance_pub.publish(kriging_variance_ros)

        self.numSamples = 0
        self.numSamplespub = rospy.Publisher(namespace + node_name + "/" + "numSamples", Int64, queue_size=0, tcp_nodelay=True, latch=True)

        # Set of robots
        self.robots = ["robot_" + str(r) for r in range(self.num_robots)]
        self.robot_pose_pubs = {}
        for robot in self.robots:
            self.robot_pose_pubs[robot] = rospy.Publisher("/" + robot + "/cmd_pose", Pose, queue_size=1)

        rospy.loginfo("Robots: " + str(self.robots))

    
    def sim_time_factor_callback(self, msg):
        self.sim_time_factor = msg.data
    

    def grid_sampling(self):
        # Create grid of points to sample
        # 20 points spread evenly across the x axis, with a 5% margin on each of the edges
        sample_grid_x = np.linspace(min(x_grid) + max(x_grid) * 0.05, max(x_grid) - max(x_grid) * 0.05, 10)
        # 20 points spread evenly across the y axis, with a 5% margin on each of the edges
        sample_grid_y = np.linspace(min(y_grid) + max(y_grid) * 0.05, max(y_grid) - max(y_grid) * 0.05, 10)
        
        points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                           len(sample_grid_x))]))
        plt.imshow(ground_truth, origin="lower")
        plt.colorbar()
        # Plot X and Y of points.geoms tuples
        plt.plot([p.x for p in points.geoms], [p.y for p in points.geoms], 'ro')
        plt.title("Ground truth with sampling grid")
        plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png')
        rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path + "/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png")
        
        # Convert points.geoms into list of tuples and return
        return [(p.x, p.y) for p in points.geoms]
    
    def random_sampling(self):
        # Create random points to sample
        points = [(np.random.uniform(min(x_grid), max(x_grid)), np.random.uniform(min(y_grid),
                    max(y_grid))) for _ in range(self.num_robots)]
        plt.imshow(ground_truth, origin="lower")
        plt.colorbar()
        # Plot X and Y of tuples
        plt.plot([p[0] for p in points], [p[1] for p in points], 'ro')
        plt.title("Ground truth with initial random sampling")
        plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_random_sampling.png')
        rospy.loginfo("Saved ground truth and random sampling plot to " + package_path + "/include/stage_soil_mapping_mrs/ground_truth_and_random_sampling.png")

        return points


    def calculate_path_cost(self, robot_position, task_position):
        # Calculate path cost
        # Euclidean distance between robot and task, multiplied by constant robot_speed
        return np.sqrt((robot_position[0] - task_position[0]) ** 2 + (robot_position[1] - task_position[1]) ** 2) * self.robot_speed


    def rr_ta(self):  # Round Robin Task Allocation
        rospy.loginfo("Executing Round Robin Task Allocation...")
        ta = {}
        for robot in self.robots:
            ta[robot] = []
        print("Robots are: " + str(self.robots))
        for _ in range(len(self.tasks)):
            task = self.tasks.pop(0)
            # print("Robot ID for current allocation is " + str(self.rr_rob_index))
            ta["robot_" + str(self.rr_rob_index)].append(task)
            if self.rr_rob_index == len(self.robots) - 1:
                self.rr_rob_index = 0
            else:
                self.rr_rob_index += 1
        return ta
    

    def ssi_ta(self): # Sequential Single-Item Task Allocation
        rospy.loginfo("Executing Sequential Single-Item Task Allocation...")
        ta = {}
        for robot in self.robots:
            ta[robot] = []
        print("Robots are: " + str(self.robots))
        for _ in range(len(self.tasks)):
            task = self.tasks.pop(0)
            bids = []
            for robot in self.robots:
                # Get robot position
                robot_pose_msg = rospy.wait_for_message("/" + robot + "/amcl_pose", PoseWithCovarianceStamped)
                robot_position = (robot_pose_msg.pose.pose.position.x, robot_pose_msg.pose.pose.position.y)

                # Calculate path cost for robot to navigate to task
                bid = self.calculate_path_cost(robot_position, task)
                bids.append(bid)
            
            rospy.loginfo("\nTask: " + str(task) + ". Bids:")
            for b in range(len(bids)):
                rospy.loginfo("robot_"+str(b)+": " + str(bids[b]))

            # Get index of max bid
            min_bid_index = bids.index(min(bids))

            rospy.loginfo("robot_"+str(min_bid_index)+" wins with bid: " + str(bids[min_bid_index]))

            ta["robot_" + str(min_bid_index)].append(task)

        # Sort each robot's task queue to minimize the distance they must travel to reach all their tasks
        for robot in self.robots:
            sorted_tasks = sorted(ta[robot], key=lambda x: self.calculate_path_cost(robot_position, x))
            ta[robot] = sorted_tasks

        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        x_arr.append([data["x"]])
        y_arr.append([data["y"]])
        o_arr.append(float(data["reading"]))
        id_arr.append(data["robot_id"])

        c_arr = []
        for i in range(len(id_arr)):
            if id_arr[i] == "robot_0":
                c_arr.append('r')
            elif id_arr[i] == "robot_1":
                c_arr.append('g')
        
        # Need at least 3 points to interpolate
        if len(x_arr) > 2:
            print("Setting sim. speed to 1x while interpolating...")

            # Set sim speed to 1x
            self.sim_time_factor_pub.publish(1.0)

            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(x_grid, y_grid, x_arr, y_arr, o_arr, variogram=variogram)

            self.interpolated_map, self.kriging_variance = m, v
            # Publish interpolation maps
            interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
            kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
            self.interpolated_map_pub.publish(interpolated_map_ros)
            self.kriging_variance_pub.publish(kriging_variance_ros)

            # Calculate interpolation metrics
            self.RMSE = np.sqrt(np.mean((m - ground_truth) ** 2))
            self.avgVar = np.mean(v)

            rospy.loginfo("Interpolation complete")
            
            print("Setting sim. speed back to " + str(increased_sim_speed) + "x...")
            self.sim_time_factor_pub.publish(increased_sim_speed)
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(x_arr)))

    def numpy_array_to_occupancy_grid(self, numpy_array): # Convert numpy array to OccupancyGrid message
        # Upscale numpy array by 20x for better visualisation
        numpy_array = cv2.resize(numpy_array, (numpy_array.shape[1]*20, numpy_array.shape[0]*20), interpolation=cv2.INTER_NEAREST)

        # Create OccupancyGrid message
        occupancy_grid = OccupancyGrid()
        occupancy_grid.header.frame_id = "map"
        occupancy_grid.info.resolution = 0.05
        occupancy_grid.info.width = numpy_array.shape[1]
        occupancy_grid.info.height = numpy_array.shape[0]
        occupancy_grid.info.origin.position.x = 0
        occupancy_grid.info.origin.position.y = 0
        occupancy_grid.info.origin.position.z = 0
        occupancy_grid.info.origin.orientation.x = 0
        occupancy_grid.info.origin.orientation.y = 0
        occupancy_grid.info.origin.orientation.z = 0
        occupancy_grid.info.origin.orientation.w = 1
        occupancy_grid.data = numpy_array.flatten().tolist()
        return occupancy_grid
    
    def random_edge_pose(self):
        # Choose random pose within 5m of the edge of the environment
        pose = Pose()
        
        # Choose random edge
        edge = random.randint(0, 3)
        
        if edge == 0: # North
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(env_height-6, env_height-1)
        elif edge == 1: # East
            pose.position.x = random.uniform(env_width-6, env_width-1)
            pose.position.y = random.uniform(1, env_height-1)
        elif edge == 2: # South
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(1, 6)
        elif edge == 3: # West
            pose.position.x = random.uniform(1, 6)
            pose.position.y = random.uniform(1, env_height-1)
        
        # Convert position from stage coordinates to ROS coordinates
        pose.position.x = pose.position.x - env_width/2
        pose.position.y = pose.position.y - env_height/2

        pose.orientation.w = 1

        return pose
    
    def new_sample_callback(self, data):
        self.numSamples += 1
        self.metricPubNumSamples()
        self.interpolate_and_visualise(data.data)
        self.metricPubRMSE()
        self.metricPubAvgVariance()

        # Generate new sampling goals
        if "grid" not in self.sampling_algo:
            if "random" in self.sampling_algo:
                self.tasks += self.random_sampling()
            
            if "round" in str(self.ta_algo).lower() or "robin" in str(self.ta_algo).lower() or "rr" in str(self.ta_algo).lower():
                rospy.loginfo("Round robin running with ta_algo selected: " + str(self.ta_algo))
                self.publish_ta(self.rr_ta())
            if "SSI" in str(self.ta_algo).upper():
                rospy.loginfo("SSI running with ta_algo selected: " + str(self.ta_algo))
                self.publish_ta(self.ssi_ta())

    def metricPubRMSE(self): # Publish Root Mean Squared Error
        self.RMSEpub.publish(self.RMSE)
        rospy.loginfo("Root Mean Squared Error: %.2f" % self.RMSE)

    def metricPubAvgVariance(self): # Publish Average Kriging Variance
        self.avgVarpub.publish(self.avgVar)

    def metricPubNumSamples(self): # Publish Number of Samples
        self.numSamplespub.publish(self.numSamples)


if __name__ == '__main__':
    myargv = rospy.myargv(argv=sys.argv)

    if len(myargv) > 0:
        trial_num = int(myargv[1])
        num_robots = int(myargv[2])
        ta_algo = myargv[3]
        sampling_algo = myargv[4]
        env_crop_factor = int(myargv[5])

        coordinator = Coordinator(trial_num, num_robots, ta_algo, sampling_algo, env_crop_factor)
    else:
        rospy.logerr("No args provided")
        sys.exit(1)



    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))
    if len(pen_reading_topics) == 0:
        rospy.logerr("No topics found for simulated penetrometer readings, is the simulation running?")
        sys.exit(1)

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)

    rospy.loginfo("Waiting for simulation to start before publishing initial poses")
    sleep(5)

    # Set initial robot poses according to the chosen alogrithm
    if robot_init_pose_algorithm == "realistic": # Set robot poses within 5m of the field's gate (Northwestern corner)
        rospy.loginfo("Setting robot poses using 'realistic' algorithm")
        for robot in coordinator.robots:
            pose = Pose()
            pose.position.x = random.uniform(1, 5)
            pose.position.y = random.uniform(env_height-6, env_height-1)

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            pose.orientation.w = 1
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge":
        rospy.loginfo("Setting robot poses using 'random edge' algorithm")
        for robot in coordinator.robots:
            # Random edge
            # 0 = North, 1 = East, 2 = South, 3 = West
            edge = random.randint(0, 3)

            # Choose random pose within 5m of the edge
            pose = coordinator.random_edge_pose()
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge and robot":
        rospy.loginfo("Setting robot poses using 'random edge and robot' algorithm")
        first_robot_pose = Pose()
        first_robot = True

        for robot in coordinator.robots:
            if first_robot:
                pose = coordinator.random_edge_pose()
                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
                first_robot_pose = pose
                first_robot = False
            else:
                # Choose random pose within 5m of the edge and the first robot
                pose = coordinator.random_edge_pose()
                distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)
                while distance > 5:
                    pose = coordinator.random_edge_pose()
                    distance = sqrt((pose.position.x - first_robot_pose.position.x)**2 + (pose.position.y - first_robot_pose.position.y)**2)

                coordinator.robot_pose_pubs[robot].publish(pose)
                rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random":
        rospy.loginfo("Setting robot poses using 'random' algorithm")
        for robot in coordinator.robots:
            pose = Pose()
            pose.position.x = random.uniform(1, env_width-1)
            pose.position.y = random.uniform(1, env_height-1)
            pose.orientation.w = 1

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            coordinator.robot_pose_pubs[robot].publish(pose)


            

    # Wait for robot initial poses to be registered in the simulation
    rospy.loginfo("Waiting for robot initial poses to be registered in the simulation")
    sleep(10)

    # Publish to '/sim_initialized' topic
    rospy.loginfo("Publishing to '/sim_initialized' topic")
    coordinator.sim_initialized_pub.publish(True)
    
    # Initial task allocation
    if "round" in str(coordinator.ta_algo).lower() or "robin" in str(coordinator.ta_algo).lower() or "rr" in str(coordinator.ta_algo).lower():
        # Get Round Robin task allocations
        task_allocations = coordinator.rr_ta()
        rospy.loginfo("Round robin task allocations: " + str(task_allocations))
        plt.close()
        plt.imshow(ground_truth, origin="lower")
        for robot in coordinator.robots:
            if robot == "robot_0":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
            elif robot == "robot_1":
                plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
        plt.savefig(package_path+'/include/stage_soil_mapping_mrs/round_robin_task_allocation.png')
    elif "SSI" in str(coordinator.ta_algo).upper():
        task_allocations = coordinator.ssi_ta()
        rospy.loginfo("SSI task allocations: " + str(task_allocations))
    
    coordinator.publish_ta(task_allocations)

    # Speed up simulation and keep coordinator node running until ROS is shutdown
    coordinator.sim_time_factor_pub.publish(increased_sim_speed)
    rospy.spin()
