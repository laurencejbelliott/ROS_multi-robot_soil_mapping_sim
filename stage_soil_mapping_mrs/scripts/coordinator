#!/usr/bin/env python3
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
import copy
import cv2
from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String, Float64, Int64
from nav_msgs.msg import OccupancyGrid
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

# TODO:
# - Add GitHub ROS package dependencies as Git submodules
# - Create script to record rosbag and generate summary statistics of metrics
# - Visualise sampling points in RViz
# - Implement additional metrics calculated in Mesa simulation
# - Port dynamic sampling from Mesa simulation
# - Integrate a more sophisticated task allocation algorithm

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()


# Define parameters (Explanations are in kriging.py)
# Use Gaussian variogram model
variogram = 'gaussian'

# Set kriging grid dimensions to those the environment
x_grid = np.arange(0, ground_truth.shape[1], 1)
y_grid = np.arange(0, ground_truth.shape[0], 1)

# Define location and data of sampled points
x_arr = []
y_arr = []
o_arr = []
id_arr = []

# Create grid of points to sample
# 20 points spread evenly across the x axis, with a 5% margin on each of the edges
sample_grid_x = np.linspace(min(x_grid) + max(x_grid) * 0.05, max(x_grid) - max(x_grid) * 0.05, 10)
# 20 points spread evenly across the y axis, with a 5% margin on each of the edges
sample_grid_y = np.linspace(min(y_grid) + max(y_grid) * 0.05, max(y_grid) - max(y_grid) * 0.05, 10)

points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                        len(sample_grid_x))]))
# print("Points: {}".format(points))
plt.imshow(ground_truth, origin="lower")
plt.colorbar()
plt.plot([point.x for point in points], [point.y for point in points], 'bo')
plt.title("Ground truth with sampling grid")
plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png')
rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path +
              "/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png")


class Coordinator:
    def __init__(self):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        self.rr_rob_index = 0
        self.tasks = [(point.x, point.y) for point in points]

        # Define metrics
        self.RMSE = -1
        self.RMSEpub = rospy.Publisher(namespace + node_name + "/" + "RMSE", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.avgVar = -1
        self.avgVarpub = rospy.Publisher(namespace + node_name + "/" + "avgVar", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        
        # Initialise kriging maps
        self.interpolated_map = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.kriging_variance = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.interpolated_map_pub = rospy.Publisher(namespace + node_name + "/" + "interpolated_map", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)
        self.kriging_variance_pub = rospy.Publisher(namespace + node_name + "/" + "kriging_variance", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        # Publish placeholder maps before any data is received
        interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
        kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
        self.interpolated_map_pub.publish(interpolated_map_ros)
        self.kriging_variance_pub.publish(kriging_variance_ros)

        self.numSamples = 0
        self.numSamplespub = rospy.Publisher(namespace + node_name + "/" + "numSamples", Int64, queue_size=0, tcp_nodelay=True, latch=True)

        # Set of robots
        self.robots = ["robot_0", "robot_1"]
        rospy.loginfo("Robots: " + str(self.robots))

    def rr_ta(self):  # Round Robin Task Allocation
        ta = {"robot_0": [], "robot_1": []}
        print("Robots are: " + str(self.robots))
        for task in self.tasks:
            print("Robot ID for current allocation is " + str(self.rr_rob_index))
            ta["robot_" + str(self.rr_rob_index)].append(task)
            if self.rr_rob_index == len(self.robots) - 1:
                self.rr_rob_index = 0
            else:
                self.rr_rob_index += 1
        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        x_arr.append([data["x"]])
        y_arr.append([data["y"]])
        o_arr.append(float(data["reading"]))
        id_arr.append(data["robot_id"])

        # rospy.loginfo("x_arr len: " + str(len(x_arr)))
        # rospy.loginfo("y_arr len: " + str(len(y_arr)))
        # rospy.loginfo("o_arr len: " + str(len(o_arr)))
        # rospy.loginfo("id_arr len: " + str(len(id_arr)))

        c_arr = []
        for i in range(len(id_arr)):
            if id_arr[i] == "robot_0":
                c_arr.append('r')
            elif id_arr[i] == "robot_1":
                c_arr.append('g')

        # rospy.loginfo("c_arr len: " + str(len(c_arr)))

        # Need at least 3 points to interpolate
        if len(x_arr) > 2:
            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(x_grid, y_grid, x_arr, y_arr, o_arr, variogram=variogram)

            self.interpolated_map, self.kriging_variance = m, v
            # Publish interpolation maps
            interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
            kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
            self.interpolated_map_pub.publish(interpolated_map_ros)
            self.kriging_variance_pub.publish(kriging_variance_ros)

            # Calculate interpolation metrics
            self.RMSE = np.sqrt(np.mean((m - ground_truth) ** 2))
            self.avgVar = np.mean(v)

            # # Plot interpolated map
            # plt.close()

            # # Fix mismatched array lengths
            # c_arr_fixed = []
            # if len(c_arr) < len(x_arr):
            #     c_arr_fixed = copy.copy(c_arr)
            #     if c_arr[-1] == 'r':
            #         c_arr_fixed.append('g')
            #     elif c_arr[-1] == 'g':
            #         c_arr_fixed.append('r')
            #     plt.scatter(x_arr, y_arr, c=c_arr_fixed)
            # else:    
            #     plt.scatter(x_arr, y_arr, c=c_arr)
            # plt.imshow(m, origin="lower")
            # plt.title("Interpolation of " + str(len(x_arr)) + " samples")
            # plt.colorbar()
            # plt.savefig(package_path+'/include/stage_soil_mapping_mrs/interpolated.png')
            # rospy.loginfo("Saved interpolation plot to " + package_path+"/include/stage_soil_mapping_mrs/interpolated.png")
            # plt.show(block=False)
            # plt.pause(1)

            # # Plot variance map
            # plt.close()

            # # Fix mismatched array lengths
            # c_arr_fixed = []
            # if len(c_arr) < len(x_arr):
            #     c_arr_fixed = copy.copy(c_arr)
            #     if c_arr[-1] == 'r':
            #         c_arr_fixed.append('g')
            #     elif c_arr[-1] == 'g':
            #         c_arr_fixed.append('r')
            #     plt.scatter(x_arr, y_arr, c=c_arr_fixed)
            # else:    
            #     plt.scatter(x_arr, y_arr, c=c_arr)
            # plt.imshow(v, origin="lower")
            # plt.title("Kriging variance from " + str(len(x_arr)) + " samples")
            # plt.colorbar()
            # plt.savefig(package_path+'/include/stage_soil_mapping_mrs/variance.png')
            # rospy.loginfo("Saved interpolation plot to " + package_path+"/include/stage_soil_mapping_mrs/variance.png")

            rospy.loginfo("Interpolation complete")
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(x_arr)))


    def numpy_array_to_occupancy_grid(self, numpy_array): # Convert numpy array to OccupancyGrid message
        # Upscale numpy array by 20x for better visualisation
        numpy_array = cv2.resize(numpy_array, (numpy_array.shape[1]*20, numpy_array.shape[0]*20), interpolation=cv2.INTER_NEAREST)

        # Create OccupancyGrid message
        occupancy_grid = OccupancyGrid()
        occupancy_grid.header.frame_id = "map"
        occupancy_grid.info.resolution = 0.05
        occupancy_grid.info.width = numpy_array.shape[1]
        occupancy_grid.info.height = numpy_array.shape[0]
        occupancy_grid.info.origin.position.x = 0
        occupancy_grid.info.origin.position.y = 0
        occupancy_grid.info.origin.position.z = 0
        occupancy_grid.info.origin.orientation.x = 0
        occupancy_grid.info.origin.orientation.y = 0
        occupancy_grid.info.origin.orientation.z = 0
        occupancy_grid.info.origin.orientation.w = 1
        occupancy_grid.data = numpy_array.flatten().tolist()
        return occupancy_grid
    
    def new_sample_callback(self, data):
        self.numSamples += 1
        self.metricPubNumSamples()
        self.interpolate_and_visualise(data.data)
        self.metricPubRMSE()
        self.metricPubAvgVariance()

    def metricPubRMSE(self): # Publish Root Mean Squared Error
        self.RMSEpub.publish(self.RMSE)
        rospy.loginfo("Root Mean Squared Error: %.2f" % self.RMSE)

    def metricPubAvgVariance(self): # Publish Average Kriging Variance
        self.avgVarpub.publish(self.avgVar)

    def metricPubNumSamples(self): # Publish Number of Samples
        self.numSamplespub.publish(self.numSamples)

    # def getTotalDistance(self):
    #     current_robot_distances = []
    #     for distances in self.robot_travel_distances.values():
    #         current_robot_distances.append(distances[-1])

    #     return np.sum(current_robot_distances)

    # def getTotalIdleTime(self):
    #     current_robot_idle_times = []
    #     for idle_times in self.robot_idle_times.values():
    #         current_robot_idle_times.append(idle_times[-1])

    #     return np.sum(current_robot_idle_times)

    # def getMaxVisits(self):
    #     return np.max(self.combined_cells_visited)

    # def getTotalTaskCompletionTime(self):
    #     task_completion_times = []
    #     for agent in self.schedule.agents:
    #         if agent.type == 0:
    #             task_completion_times.append(np.sum(agent.task_completion_times))

    #     return np.sum(task_completion_times)

    # def getAvgTaskCompletionTime(self):
    #     task_completion_times = []
    #     for agent in self.schedule.agents:
    #         if agent.type == 0:
    #             task_completion_times.append(np.mean(agent.task_completion_times))

    #     return np.mean(task_completion_times)


if __name__ == '__main__':
    coordinator = Coordinator()

    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)

    # Get Round Robin task allocations
    task_allocations = coordinator.rr_ta()
    rospy.loginfo("Round robin task allocations: " + str(task_allocations))
    plt.close()
    plt.imshow(ground_truth, origin="lower")
    for robot in coordinator.robots:
        if robot == "robot_0":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
        elif robot == "robot_1":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
    plt.savefig(package_path+'/include/stage_soil_mapping_mrs/round_robin_task_allocation.png')

    coordinator.publish_ta(task_allocations)
    rospy.spin()
