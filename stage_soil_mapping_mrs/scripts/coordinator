#!/usr/bin/env python3
__author__ = "Laurence Roberts-Elliott"

import numpy as np
import pickle
import rospy
import rospkg
import json
import random
import copy
import cv2
from matplotlib import pyplot as plt
from kriging_utils.kriging import predict_by_kriging
from std_msgs.msg import String, Float64, Int64, Bool
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose
from move_base_msgs.msg import MoveBaseGoal
from shapely.geometry import MultiPoint
import matplotlib
matplotlib.use('Agg')

# Set random seed for reproducibility
random.seed(0)

# TODO:
# - Alternate algorithms for robot intitial positions
#  * Realistic, within a maximum distance from a gate where robots can enter the field - 'realstic'
#  * Random with a maximum distance from the edge of the map - 'random edge'
#  * Random with a maximum distance from the edge of the map, and a maximum distance from another robot - 'random edge and robot'
# - Visualise kriging variance in RViz
# - Visualise sampling points in RViz
# - Port dynamic sampling from Mesa simulation
# - Integrate one or two more sophisticated task allocation algorithm
# - Dynamic sampling improvements (co-kriging, quadtree environment partitioning, etc.)

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle', 'rb') as f:
    ground_truth = pickle.load(f)

node_name = 'coordinator'
namespace = rospy.get_namespace()

increased_sim_speed = 500 # 500x faster than real time
env_width = 324 # metres
env_height = 220 # metres
robot_init_pose_algorithm = 'realistic' # 'realistic', 'random edge', 'random edge and robot'

# Define parameters (Explanations are in kriging.py)
# Use Gaussian variogram model
variogram = 'gaussian'

# Set kriging grid dimensions to those the environment
x_grid = np.arange(0, ground_truth.shape[1], 1)
y_grid = np.arange(0, ground_truth.shape[0], 1)

# Define location and data of sampled points
x_arr = []
y_arr = []
o_arr = []
id_arr = []

# Create grid of points to sample
# 20 points spread evenly across the x axis, with a 5% margin on each of the edges
sample_grid_x = np.linspace(min(x_grid) + max(x_grid) * 0.05, max(x_grid) - max(x_grid) * 0.05, 10)
# 20 points spread evenly across the y axis, with a 5% margin on each of the edges
sample_grid_y = np.linspace(min(y_grid) + max(y_grid) * 0.05, max(y_grid) - max(y_grid) * 0.05, 10)

points = MultiPoint(np.transpose([np.tile(sample_grid_x, len(sample_grid_y)), np.repeat(sample_grid_y,
                                                                                        len(sample_grid_x))]))
# print("Points: {}".format(points))
plt.imshow(ground_truth, origin="lower")
plt.colorbar()
plt.plot([point.x for point in points.geoms], [point.y for point in points.geoms], 'bo')
plt.title("Ground truth with sampling grid")
plt.savefig(package_path+'/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png')
rospy.loginfo("Saved ground truth and sampling grid plot to " + package_path +
              "/include/stage_soil_mapping_mrs/ground_truth_and_sampling.png")


class Coordinator:
    def __init__(self):
        rospy.init_node(node_name, anonymous=True)
        rospy.loginfo("Coordinator node initialised")
        self.rr_rob_index = 0
        self.tasks = [(point.x, point.y) for point in points.geoms]
        self.start_time = rospy.Time.now().to_sec()
        self.sampling_time_budget = 60 * 120 # 2 hours (60 seconds * 120 for 120 minutes in seconds)

        self.sim_time_factor = 1  # Default to 1x sim speed, gets updated by sim_time_factor_callback
        self.sim_time_factor_sub = rospy.Subscriber("/sim_time_factor", Float64, self.sim_time_factor_callback)
        # self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.sim_time_factor_pub = rospy.Publisher("/sim_time_factor", Float64, latch=True)

        # Define metrics
        self.RMSE = -1
        self.RMSEpub = rospy.Publisher(namespace + node_name + "/" + "RMSE", Float64, queue_size=0, tcp_nodelay=True, latch=True)
        self.avgVar = -1
        self.avgVarpub = rospy.Publisher(namespace + node_name + "/" + "avgVar", Float64, queue_size=0, tcp_nodelay=True, latch=True)

        self.sampling_time_budget_elapsed_pub = rospy.Publisher("/sampling_time_budget_elapsed", Bool, queue_size=1)

        # Initialise kriging maps
        self.interpolated_map = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.kriging_variance = np.ones((ground_truth.shape[0], ground_truth.shape[1])) * -1
        self.interpolated_map_pub = rospy.Publisher(namespace + node_name + "/" + "interpolated_map", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)
        self.kriging_variance_pub = rospy.Publisher(namespace + node_name + "/" + "kriging_variance", OccupancyGrid, queue_size=0, tcp_nodelay=True, latch=True)

        # Publish placeholder maps before any data is received
        interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
        kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
        self.interpolated_map_pub.publish(interpolated_map_ros)
        self.kriging_variance_pub.publish(kriging_variance_ros)

        self.numSamples = 0
        self.numSamplespub = rospy.Publisher(namespace + node_name + "/" + "numSamples", Int64, queue_size=0, tcp_nodelay=True, latch=True)

        # Set of robots
        self.robots = ["robot_0", "robot_1"]
        self.robot_pose_pubs = {}
        for robot in self.robots:
            self.robot_pose_pubs[robot] = rospy.Publisher("/" + robot + "/cmd_pose", Pose, queue_size=1)

        rospy.loginfo("Robots: " + str(self.robots))

    
    def sim_time_factor_callback(self, msg):
        self.sim_time_factor = msg.data
    
    def rr_ta(self):  # Round Robin Task Allocation
        ta = {"robot_0": [], "robot_1": []}
        print("Robots are: " + str(self.robots))
        for task in self.tasks:
            print("Robot ID for current allocation is " + str(self.rr_rob_index))
            ta["robot_" + str(self.rr_rob_index)].append(task)
            if self.rr_rob_index == len(self.robots) - 1:
                self.rr_rob_index = 0
            else:
                self.rr_rob_index += 1
        return ta


    def publish_ta(self, task_allocations):
        # Publish task allocations to robots
        for robot in self.robots:
            new_task_topic = "/" + robot + "/sampling_task_queue/add_goal"
            new_task_pub = rospy.Publisher(new_task_topic, MoveBaseGoal, queue_size=0,
                                        tcp_nodelay=True, latch=True)
            task_count = 0
            for task in task_allocations[robot][::-1]:
                task_goal = MoveBaseGoal()
                task_goal.target_pose.header.frame_id = "map"
                task_goal.target_pose.pose.position.x = task[0]
                task_goal.target_pose.pose.position.y = task[1]
                task_goal.target_pose.pose.orientation.w = 1.0
                new_task_pub.publish(task_goal)
                rospy.loginfo("Publishing task to " + robot + ": " + str(task))
                # Delay after 1st task to allow robots to start moving
                if task_count == 0:
                    rospy.sleep(2)
                else:
                    rospy.sleep(0.1)
                task_count += 1

    def interpolate_and_visualise(self, data):
        print("New sample data received:")

        # Perform kriging interpolation from values sampled by the robots
        # Parse json data
        data = data.replace("'", '"')
        data = json.loads(data)
        rospy.loginfo("Robot ID: " + str(data["robot_id"]))
        rospy.loginfo("X: " + str(data["x"]))
        rospy.loginfo("Y: " + str(data["y"]))
        rospy.loginfo("Reading: " + str(data["reading"]))

        x_arr.append([data["x"]])
        y_arr.append([data["y"]])
        o_arr.append(float(data["reading"]))
        id_arr.append(data["robot_id"])

        # rospy.loginfo("x_arr len: " + str(len(x_arr)))
        # rospy.loginfo("y_arr len: " + str(len(y_arr)))
        # rospy.loginfo("o_arr len: " + str(len(o_arr)))
        # rospy.loginfo("id_arr len: " + str(len(id_arr)))

        c_arr = []
        for i in range(len(id_arr)):
            if id_arr[i] == "robot_0":
                c_arr.append('r')
            elif id_arr[i] == "robot_1":
                c_arr.append('g')

        # rospy.loginfo("c_arr len: " + str(len(c_arr)))

        # Need at least 3 points to interpolate
        if len(x_arr) > 2:
            print("Setting sim. speed to 1x while interpolating...")

            # Set sim speed to 1x
            self.sim_time_factor_pub.publish(1.0)

            # Run interpolation of sampled points
            rospy.loginfo("Interpolating, please wait...")
            m, v = predict_by_kriging(x_grid, y_grid, x_arr, y_arr, o_arr, variogram=variogram)

            self.interpolated_map, self.kriging_variance = m, v
            # Publish interpolation maps
            interpolated_map_ros = self.numpy_array_to_occupancy_grid(self.interpolated_map.astype(np.int8))
            kriging_variance_ros = self.numpy_array_to_occupancy_grid(self.kriging_variance.astype(np.int8))
            self.interpolated_map_pub.publish(interpolated_map_ros)
            self.kriging_variance_pub.publish(kriging_variance_ros)

            # Calculate interpolation metrics
            self.RMSE = np.sqrt(np.mean((m - ground_truth) ** 2))
            self.avgVar = np.mean(v)

            rospy.loginfo("Interpolation complete")
            print("Setting sim. speed back to " + str(increased_sim_speed) + "x...")
            self.sim_time_factor_pub.publish(increased_sim_speed)
        else:
            rospy.loginfo("Need at least 3 points to interpolate, we have " + str(len(x_arr)))


    def numpy_array_to_occupancy_grid(self, numpy_array): # Convert numpy array to OccupancyGrid message
        # Upscale numpy array by 20x for better visualisation
        numpy_array = cv2.resize(numpy_array, (numpy_array.shape[1]*20, numpy_array.shape[0]*20), interpolation=cv2.INTER_NEAREST)

        # Create OccupancyGrid message
        occupancy_grid = OccupancyGrid()
        occupancy_grid.header.frame_id = "map"
        occupancy_grid.info.resolution = 0.05
        occupancy_grid.info.width = numpy_array.shape[1]
        occupancy_grid.info.height = numpy_array.shape[0]
        occupancy_grid.info.origin.position.x = 0
        occupancy_grid.info.origin.position.y = 0
        occupancy_grid.info.origin.position.z = 0
        occupancy_grid.info.origin.orientation.x = 0
        occupancy_grid.info.origin.orientation.y = 0
        occupancy_grid.info.origin.orientation.z = 0
        occupancy_grid.info.origin.orientation.w = 1
        occupancy_grid.data = numpy_array.flatten().tolist()
        return occupancy_grid
    
    def new_sample_callback(self, data):
        self.numSamples += 1
        self.metricPubNumSamples()
        self.interpolate_and_visualise(data.data)
        self.metricPubRMSE()
        self.metricPubAvgVariance()

    def metricPubRMSE(self): # Publish Root Mean Squared Error
        self.RMSEpub.publish(self.RMSE)
        rospy.loginfo("Root Mean Squared Error: %.2f" % self.RMSE)

    def metricPubAvgVariance(self): # Publish Average Kriging Variance
        self.avgVarpub.publish(self.avgVar)

    def metricPubNumSamples(self): # Publish Number of Samples
        self.numSamplespub.publish(self.numSamples)


if __name__ == '__main__':
    coordinator = Coordinator()

    # Get list of topics where robots publish their sampled values
    topics = rospy.get_published_topics()
    pen_reading_topics = [topic[0] for topic in topics if 'mock_pen_reading' in topic[0]]
    rospy.loginfo("Subscribing to simulated penetrometer reading topics: " + str(pen_reading_topics))

    for topic in pen_reading_topics:
        rospy.Subscriber(topic, String, coordinator.new_sample_callback)
        
    
    # Get Round Robin task allocations
    task_allocations = coordinator.rr_ta()
    rospy.loginfo("Round robin task allocations: " + str(task_allocations))
    plt.close()
    plt.imshow(ground_truth, origin="lower")
    for robot in coordinator.robots:
        if robot == "robot_0":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'ro')
        elif robot == "robot_1":
            plt.plot([task[0] for task in task_allocations[robot]], [task[1] for task in task_allocations[robot]], 'go')
    plt.savefig(package_path+'/include/stage_soil_mapping_mrs/round_robin_task_allocation.png')

    # Set initial robot poses according to the chosen alogrithm
    if robot_init_pose_algorithm == "realistic": # Set robot poses within 5m of the field's gate (Northwestern corner)
        for robot in coordinator.robots:
            pose = Pose()
            pose.position.x = random.uniform(1, 5)
            pose.position.y = random.uniform(env_height-6, env_height-1)

            # Convert position from stage coordinates to ROS coordinates
            pose.position.x = pose.position.x - env_width/2
            pose.position.y = pose.position.y - env_height/2

            pose.orientation.w = 1
            coordinator.robot_pose_pubs[robot].publish(pose)
            rospy.loginfo("Published initial pose of " + robot + " on topic " + coordinator.robot_pose_pubs[robot].name + ": " + str(pose))
    elif robot_init_pose_algorithm == "random edge":
        pass # TODO    
    
    coordinator.publish_ta(task_allocations)

    # Speed up simulation
    coordinator.sim_time_factor_pub.publish(increased_sim_speed)

    # Check if sampling time budget has elapsed
    while not rospy.is_shutdown():
        now = rospy.Time.now().to_sec()
        if now - coordinator.start_time > coordinator.sampling_time_budget:
            rospy.loginfo("Sampling time budget elapsed (%s seconds)" % coordinator.sampling_time_budget)
            coordinator.sampling_time_budget_elapsed_pub.publish(True)
            rospy.signal_shutdown("Sampling time budget elapsed")
            break
        rospy.sleep(0.1)
