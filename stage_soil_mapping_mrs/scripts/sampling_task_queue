#!/usr/bin/env python3
import math
import rospy
import rospkg
import actionlib
import pickle
import copy
import os
import sys
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from std_msgs.msg import String, Float32MultiArray
from geometry_msgs.msg import Pose
from nav_msgs.msg import Odometry
from stage_soil_mapping_mrs.msg import InsertTask
# TODO: Add rospy_message_converter to rosdep dependencies
from rospy_message_converter import message_converter
import numpy as np
import pandas as pd

# TODO:
#  - Retry failed goals x times, then cancel goal and remove from queue

rospack = rospkg.RosPack()
package_path = rospack.get_path('stage_soil_mapping_mrs')
node_name = 'sampling_task_queue'
rospy.init_node(node_name)
namespace = rospy.get_namespace()
robot_name = namespace.strip("/")
print(namespace)

trial_name = "test_run"

# Get command line arguments
myargv = rospy.myargv(argv=sys.argv)
if len(myargv) > 1:
    trial_name = myargv[1]

    rospy.loginfo("Trial name: " + trial_name)

# Simplified navigation - teleports the robots to the goal positions after a delay calculated from the distance to the
# goal and a constant velocity, this may be used to enable faster simulation, as move_base bottlenecked sim performance.
# use_simplified_nav = rospy.get_param(namespace+node_name+'/use_simplified_nav')
use_simplified_nav = False  # Simply set as `True` for now to debug. TODO: implement this as a ROS param, as above

if not use_simplified_nav:
    client = actionlib.SimpleActionClient(namespace+'move_base', MoveBaseAction)
    rospy.loginfo(robot_name + " waiting for move_base actionserver...")
    client.wait_for_server()
    rospy.loginfo(robot_name + " connected to move_base actionserver!")

goal_queue = []
sample_positions = []
robot_speed = 0.4  # m/s
task_completion_times = []
goal_queue_pub = rospy.Publisher(namespace+node_name+"/goal_queue", String, queue_size=1)
sample_positions_pub = rospy.Publisher(namespace+node_name+"/sample_positions", String, queue_size=1)
cmd_pose_pub = rospy.Publisher(namespace+'cmd_pose', Pose, queue_size=1)
task_completion_times_pub = rospy.Publisher(namespace+node_name+"/task_completion_times", Float32MultiArray, queue_size=1, latch=True)
global current_pose

# Task logging dataframe (task_queue_length is the length of the queue at the time of allocation)
task_log = pd.DataFrame(columns=['robot_id', 'x', 'y', 'reading', 'allocation_time', 'insertion_ix', 'task_queue_length', 'start_time', 'end_time', 'exec_time'])
tasks = {} # Dict to store task information for logging (each task represented by its own dictionary)


def stage_ground_truth_pose_cb(odom_msg):
    global current_pose
    current_pose = odom_msg.pose.pose


stage_ground_truth_pose_sub = rospy.Subscriber(namespace+'base_pose_ground_truth', Odometry,
                                               stage_ground_truth_pose_cb)


def queue_nav_goal_callback(data):
    rospy.loginfo("New goal received: " + str(data.target_pose.pose.position.x) + "," +
                  str(data.target_pose.pose.position.y))
    rospy.loginfo("Goal queue length: " + str(len(goal_queue)))

    task_id = str((math.floor(data.target_pose.pose.position.x), math.floor(data.target_pose.pose.position.y)))
    tasks[task_id] = {
        'robot_id': namespace.strip("/"),
        'x': data.target_pose.pose.position.x,
        'y': data.target_pose.pose.position.y,
        'allocation_time': rospy.get_time(),
        'insertion_ix': len(goal_queue),
        'task_queue_length': len(goal_queue),
        'start_time': "NaN",
        'end_time': "NaN",
        'exec_time': "NaN",
        'reading': 'NaN'
        }
    
    goal_queue.append(data)

    # Human-readable goal queue
    goal_queue_hr = []
    for goal in goal_queue:
        goal_queue_hr.append([goal.target_pose.pose.position.x, goal.target_pose.pose.position.y])

    if len(goal_queue) > 0:
        goal_queue_pub.publish(str(goal_queue_hr))
        rospy.loginfo("\nNav goal queue:")
        for g in range(len(goal_queue)):
            rospy.loginfo("\nGoal at queue position " + str(g) + ":\n" + str(goal_queue[g].target_pose.pose.position))


def insert_nav_goal_callback(data):
    index = data.index
    goal = data.goal

    rospy.loginfo("New goal received: " + str(goal.target_pose.pose.position.x) + "," +
                    str(goal.target_pose.pose.position.y) + " at index " + str(index))
    rospy.loginfo("Goal queue length: " + str(len(goal_queue)))
    
    task_id = str((math.floor(goal.target_pose.pose.position.x), math.floor(goal.target_pose.pose.position.y)))
    tasks[task_id] = {
        'robot_id': namespace.strip("/"),
        'x': goal.target_pose.pose.position.x,
        'y': goal.target_pose.pose.position.y,
        'allocation_time': rospy.get_time(),
        'insertion_ix': index,
        'task_queue_length': len(goal_queue),
        'start_time': "NaN",
        'end_time': "NaN",
        'exec_time': "NaN",
        'reading': 'NaN'
        }

    goal_queue.insert(index, goal)

    # Human-readable goal queue
    goal_queue_hr = []
    for goal in goal_queue:
        goal_queue_hr.append([goal.target_pose.pose.position.x, goal.target_pose.pose.position.y])

    if len(goal_queue) > 0:
        goal_queue_pub.publish(str(goal_queue_hr))
        # rospy.loginfo("\nNav goal queue:")
        # for g in range(len(goal_queue)):
            # rospy.loginfo("\nGoal at queue position " + str(g) + ":\n" + str(goal_queue[g].target_pose.pose.position))


# def set_goal_queue_callback(data):
#     global goal_queue
#     goal_queue = []

#     rospy.loginfo("New goal queue received: " + str(data.data))
#     # Convert JSON list of lists (new_goal_queue_hr) to list of MoveBaseGoal objects (goal_queue)
#     new_goal_queue_hr = json.loads(data.data)

#     for goal in new_goal_queue_hr:
#         new_goal = MoveBaseGoal()
#         new_goal.target_pose.pose.position.x = goal[0]
#         new_goal.target_pose.pose.position.y = goal[1]
#         new_goal.target_pose.pose.orientation.w = 1.0
#         goal_queue.append(new_goal)
    

def pub_mock_pen_reading(goal):
    # If nav. was successful, stop for 5 seconds and read data indexed by position
    rospy.loginfo("Taking penetrometer reading...")
    if use_simplified_nav:
        # TODO: Calculate this offset as half of the environment size, rather than hard-coding it
        pose_x = goal.target_pose.pose.position.x
        pose_y = goal.target_pose.pose.position.y
        # data_x, data_y = math.floor(pose_x), math.floor(pose_y)
        data_x, data_y = math.floor(pose_x), math.floor(pose_y)
    else:
        pose_x = goal.target_pose.pose.position.x
        pose_y = goal.target_pose.pose.position.y
        data_x, data_y = math.floor(pose_x), math.floor(pose_y)
    rospy.sleep(1)
    mock_reading = mock_pen_data[data_y, data_x]

    # Add reading to task dictionary
    tasks[str((math.floor(pose_x), math.floor(pose_y)))]['reading'] = mock_reading

    reading_dict = {'robot_id': namespace.strip("/"), 'x': pose_x, 'y': pose_y, 'reading': mock_reading}
    rospy.loginfo(namespace[1:-1] + " sampled " + str(reading_dict))
    reading_msg = message_converter.convert_dictionary_to_ros_message('std_msgs/String',
                                                                      {'data': str(reading_dict)})
    mock_pen_reading_pub.publish(reading_msg)

    # Create task log dataframe from task dictionaries
    global task_log
    task_log = pd.DataFrame.from_dict(tasks, orient='index')

    # Save task log to CSV file, with robot_id in filename
    # First check if the logs directory exists, if not, create it
    try:
        os.makedirs(package_path + '/logs/'+trial_name+'/')
    except FileExistsError:
        pass

    # Save the file
    task_log.to_csv(package_path + '/logs/'+trial_name+'/task_log_' + namespace[1:-1] + '.csv')
    rospy.loginfo("Task log saved to " + package_path + '/logs/'+trial_name+'/task_log_' + namespace[1:-1] + '.csv')

    # rospy.loginfo("Task log:\n" + str(task_log))



def queue_nav_goal_listener():
    rospy.Subscriber(namespace+node_name+'/add_goal', MoveBaseGoal, queue_nav_goal_callback)
    rospy.Subscriber(namespace+node_name+'/insert_goal', InsertTask, insert_nav_goal_callback)
    # rospy.Subscriber(namespace+node_name+'/set_goal_queue', String, set_goal_queue_callback)

    r = rospy.Rate(1)
    while not rospy.is_shutdown():
        if len(goal_queue) > 0:
            # Publish human-readable goal queue
            goal_queue_hr = []
            for goal in goal_queue:
                goal_queue_hr.append([goal.target_pose.pose.position.x, goal.target_pose.pose.position.y])
            goal_queue_pub.publish(str(goal_queue_hr))

            goal = goal_queue[0]
            if not use_simplified_nav:
                client.send_goal(goal)

            rospy.loginfo("Executing goal: " + str(goal.target_pose.pose.position))
            rospy.loginfo("Sending navigation goal for sampling position...")

            goal_start_time = rospy.get_time()

            # Add start time to task dictionary
            tasks[str((math.floor(goal.target_pose.pose.position.x), math.floor(goal.target_pose.pose.position.y)))]['start_time'] = goal_start_time

            if not use_simplified_nav:
                wait = client.wait_for_result()
            else:
                # Calculate time to goal
                current_pose_x = current_pose.position.x
                current_pose_y = current_pose.position.y

                goal_pose_x = goal.target_pose.pose.position.x
                goal_pose_y = goal.target_pose.pose.position.y

                distance_to_goal = math.sqrt((goal_pose_x - current_pose_x) ** 2 + (goal_pose_y - current_pose_y) ** 2)

                time_to_goal = distance_to_goal * robot_speed  # Calculate time to travel to the goal in seconds
                rospy.loginfo("Robot navigating for " + str(time_to_goal) + " seconds to goal...")
                rospy.sleep(time_to_goal)

                # TODO: Calculate this offset as half of the environment size, rather than hard-coding it
                offset_goal = copy.deepcopy(goal)
                offset_goal.target_pose.pose.position.x = offset_goal.target_pose.pose.position.x - 162.0
                offset_goal.target_pose.pose.position.y = offset_goal.target_pose.pose.position.y - 110.0
                cmd_pose_pub.publish(offset_goal.target_pose.pose)

            if not use_simplified_nav:
                if not wait:
                    rospy.logerr("Cannot reach navigation server!")
                else:
                    state = client.get_state()
                    if state == 3:
                        # Publish mock penetrometer reading
                        pub_mock_pen_reading(goal)

                        # Calculate task completion time and publish all task completion times
                        goal_end_time = rospy.get_time()
                        goal_exec_time = goal_end_time - goal_start_time
                        task_completion_times.append(goal_exec_time)
                        task_completion_times_pub.publish(data=task_completion_times)

                        # Add end time to task dictionary
                        tasks[str((math.floor(goal.target_pose.pose.position.x), math.floor(goal.target_pose.pose.position.y)))]['end_time'] = goal_end_time

                        # Add execution time to task dictionary
                        tasks[str((math.floor(goal.target_pose.pose.position.x), math.floor(goal.target_pose.pose.position.y)))]['exec_time'] = goal_exec_time

                    elif state == 4:
                        rospy.logerr("Navigation goal was aborted!")
                    else:
                        rospy.logerr("Navigation goal failed!")
            else:
                # Publish mock penetrometer reading
                pub_mock_pen_reading(goal)

                # Calculate task completion time and publish all task completion times
                goal_end_time = rospy.get_time()
                goal_exec_time = goal_end_time - goal_start_time
                task_completion_times.append(goal_exec_time)
                task_completion_times_pub.publish(data=task_completion_times)

            try:
                goal_queue.pop(0)
            except IndexError:
                pass

            # Publish the human-readable goal queue without the completed goal
            goal_queue_hr = []
            for goal in goal_queue:
                goal_queue_hr.append([goal.target_pose.pose.position.x, goal.target_pose.pose.position.y])
            goal_queue_pub.publish(str(goal_queue_hr))
        else:
            goal_queue_pub.publish(str([]))
        r.sleep()
    rospy.spin()


if __name__ == '__main__':
    with open(package_path+'/include/stage_soil_mapping_mrs/ground_truth/interpolated_jaime_compaction_0cm_kpas.pickle',
              'rb') as f:
        mock_pen_data = pickle.load(f)
    mock_pen_data = np.array(mock_pen_data)

    mock_pen_reading_pub = rospy.Publisher(namespace + node_name + "/mock_pen_reading", String, queue_size=1)
    queue_nav_goal_listener()
